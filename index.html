<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Introduction to Qiskit</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>

<style type="text/css">
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>


</head>

<body>

<h1 id="toc_0">An Introduction to Quantum Computing by Qiskit</h1>

<p><a href="https://qiskit.org">Qiskit</a> is an open-source software development kit (SDK) used to program IBM&#39;s quantum computers. Qiskit is useful for working with noisy quantum computers at the level of pulses, circuits, and algorithms. Qiskit has three main components as Terra, Aqua, and Aer. This is an introductory tutorial on quantum computing, which will also get you started programming with qiskit.</p>

<h3 id="toc_1">Prerequisites</h3>

<p>This tutorial assumes knowledge of Basic Linear Algebra, Basic Quantum Mechanics, and Basic Digital logic but, most importantly, an open mind not limited to accepting only classical thinking!</p>

<h2 id="toc_2">Introduction</h2>

<p>Analogous to the bits used by classical computers, quantum computers use <em>qubits</em> as the basic unit of quantum information. But what are qubits exactly? </p>

<p>Think of an electron. Remember that the energy states of the electron are quantized and can only take on discrete values. Now, if we wish to represent a <em>bit</em> of information, we can restrict the energy of the system to be between the ground state and the first excited state. This way, the electron can only be at either of the two states, denoted by \(|0\rangle\) and \(|1\rangle\).</p>

<p><center>
<img src="images/electron.png" alt="">
</center></p>

<p>But the specialty of quantum particles like electrons is that it does <strong>not</strong> decide beforehand where it wants to be, which is why we say that is in a superposition of the states \(|0\rangle\) and \(|1\rangle\).</p>

<p>The superposition of the states can be represented as a linear combination of the original states as
\[\alpha|0\rangle \,+\, \beta |1\rangle,\] where 
\(\alpha, \beta \in \mathbb{C}\) represent the complex amplitudes of each of the states.</p>

<p>But what does an amplitude mean? The physical interpretation of this can be explained by the <em>Born rule</em>, which says that the probability of each of the quantum states is given by the square of its complex amplitude. To find the probability, we multipy on the left by the corresponding bra vector and note that these states are orthogonal and normalized, meaning \(\langle0|1\rangle=0=\langle1|0\rangle\) and \(\langle0|0\rangle=1=\langle1|1\rangle\) <em>(the reason for this will become clear)</em>.
\[P[\text{finding the electron in state }|0\rangle] = |\alpha\langle0|0\rangle + \beta \langle0|1\rangle|^2 = |\alpha|^2,\]
\[P[\text{finding the electron in state }|1\rangle] = |\alpha\langle1|0\rangle + \beta \langle1|1\rangle|^2 = |\beta|^2.\]</p>

<p>Because we have restricted the energy of the electron to be at one of the states \(|0\rangle\) or \(|1\rangle\), and since probabilities always add up to 1, we can say that</p>

<p>\[|\alpha|^2 + |\beta|^2 = 1. \]</p>

<p>This is called normalization, which captures the probabilistic thinking in QM. This is also the reason we took the states to be orthogonal \(\langle0|1\rangle=0=\langle1|0\rangle\) and normalised \(\langle0|0\rangle=1=\langle1|1\rangle\) earlier.</p>

<p>Now let us discuss what happens when we measure the system. A measurement of the system collapses the system into one of the states along which we are measuring. So the electron quickly makes up it&#39;s mind as to where it wants to be, either at the \(|0\rangle\) state or at the \(|1\rangle\) state. On measuring along the \(\{|0\rangle, |1\rangle\}\) basis, the system collapses to \(|0\rangle\) with probability \(|\alpha|^2\) and to \(|1\rangle\) with probability \(|\beta|^2\). Measuring a system along a basis is essentially multiplying the state with the corresponding bra vectors of the basis.</p>

<p>Representing the qubits by \(|0\rangle\) and \(|1\rangle\) is especially helpful while doing quantum computation, as it gives us a way to encode the fact that they represent bits 0 and 1 respectively. Addtionally, this notation captures the fact that the qubit is a much more complicated object than the classical bit.</p>

<h2 id="toc_3">Representation</h2>

<p>Now let us try to visualize and represent these states more concretely. Since there are two complex amplitudes, we can represent them as a column vector with 2 entries like so.
\[\alpha |0\rangle \,+\, \beta |1\rangle \;=\; \begin{pmatrix} \alpha\\ \beta \\ \end{pmatrix}.\]
In this representation, note that we can express our abstract labelled kets \(|0\rangle\) and \(|1\rangle\) in a mathematical way. We see that
\[|0\rangle = \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} \text{ when }\alpha = 1 \text{ and } \beta = 0,\]
\[|1\rangle = \begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} \text{ when }\alpha = 0 \text{ and } \beta = 1.\]
Notice that this representation tells us a few things about these two states. </p>

<ul>
<li>They are linearly independent, meaning that for the state to equal 0, we need each of the complex coefficients to be 0. </li>
<li>They are orthogonal meaning that under the usual definition of inner product in the 2-D complex plane, we find that these states have a inner product of 0. 
\[\langle 0|1\rangle= \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix}.\begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = 0\]
\[\langle 1|0\rangle= \begin{pmatrix} 0 \\ 1 \\ \end{pmatrix}.\begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} = 0\]</li>
<li>We also see that these two states can span the entire space. </li>
</ul>

<p>Hence we call such states to be orthonormal basis states. Recall that a basis set is a set of linearly independent vectors that span the vector space. A vector space can have any number of basis sets. </p>

<h2 id="toc_4">Uncertainty</h2>

<p>Let us now say we have a state \[|\psi\rangle = \begin{pmatrix} \cos\theta \\ \sin\theta \\ \end{pmatrix},\]
which makes an angle of \(\theta\) with the \(|0\rangle\) state. Let us make a large number of qubits which are prepared to be at the above state and then measure these qubits. When we measure them, the qubit makes up its mind as to which state it wants to be, and we find \(\cos^2\theta\) fraction of the qubits at the ground state and \(\sin^2\theta\) fraction of the qubits at the excited state. </p>

<p>Note that measurement of a system can be done in an arbitary basis and our results depend on the basis along which we perform our measurement. In the above case the measurement was done on the \(|0\rangle\) and \(|1\rangle\) basis. Now let us chose another basis \({\{|+\rangle, |-\rangle}\}\) as 
\[|+\rangle = \frac{1}{\sqrt{2}}(|0\rangle \,+\, |1\rangle),\]
\[|-\rangle = \frac{1}{\sqrt{2}}(|0\rangle \,-\, |1\rangle).\]
You can quickly verify that this does corresponds to a basis, since it is linearly independent, and spans the vector space. As a bonus we also find that this basis is also orthogonal since the inner product corresponds to 0. Now, to measure the state of the system in the \({\{|+\rangle, |-\rangle}\}\) basis, we take the inner product of the state with the basis states.
\[
\begin{align}
\langle+|\psi\rangle &amp;= \frac{1}{\sqrt{2}}(\langle0|+\langle1|)(\cos\theta|0\rangle + \sin\theta|1\rangle) \\
&amp;=\frac{1}{\sqrt 2}(\cos \theta+\sin\theta).
\end{align}
\]
Thus, the probability of finding the state \(|\psi\rangle\) in the \(|+\rangle\) state is given by
\[|\langle \,+\, |\psi\rangle|^2 = \frac{1}{2}(\cos\theta + \sin\theta)^2.\]</p>

<p>Similarly,
\[
\begin{align}
\langle-|\psi\rangle &amp;= \frac{1}{\sqrt{2}}(\langle0|-\langle1|)(\cos\theta|0\rangle + \sin\theta|1\rangle) \\
&amp;=\frac{1}{\sqrt 2}(\cos \theta-\sin\theta).
\end{align}
\]
Hence, the probability of finding the state \(|\psi\rangle\) in the \(|-\rangle\) state is
\[|\langle-|\psi\rangle|^2 = \frac{1}{2}(\cos\theta - \sin\theta)^2.\]</p>

<p>As expected, the probabilities add up to 1.
\[|\langle+|\psi\rangle|^2 +|\langle-|\psi\rangle|^2 = \frac{1}{2}(\cos\theta + \sin\theta)^2+\frac{1}{2}(\cos\theta - \sin\theta)^2=1\]</p>

<p>Let us see what happens as \(\theta\) tends to 0. As \(\theta \to 0\),
\(\sin\theta \to 0\) and \(\cos\theta \to 1\). Thus, we can deterministically claim that the qubit is in state \(|0\rangle\) when measured in the \({\{|0\rangle, |1\rangle}\}\) basis. However in the \({\{|+\rangle, |-\rangle}\}\) basis, the qubit is in the \(|+\rangle\) state with a probability of \(\frac {1}{2}\) and in the \(|-\rangle\) state with a probability of \(\frac {1}{2}\), which is the case of maximum uncertainty.</p>

<p>This is essentially <em>Heisenberg&#39;s Uncertainty principle</em>, which says that the more we know about a system in one basis, the less we know about the system in another basis. You may remember this principle relating the uncertainties of position and momentum which is a special case, since each of them form a valid basis for the vector space.</p>

<h2 id="toc_5">Bloch Sphere</h2>

<p>This is a good opportunity to introduce the <em>Bloch sphere</em>, an excellent visualization tool to see the states of a system, and how their change can be represented as a movement on the surface of the sphere. We use the fact that the states are normalized, and hence each point of a Bloch sphere represents a valid state. </p>

<p>Any normalized pure state can be represented as 
\[|\psi\rangle = \sin{\frac{\theta}{2}}|\psi_{1}\rangle \,+\,
e^{i\phi}\cos{\frac{\theta}{2}}|\psi_{2}\rangle,\] 
where \(|\psi_{1}\rangle,|\psi_{2}\rangle\) are the basis vectors, \(\theta\) is the angle made by the z-axis and \(\phi\) is the angle made by the projection of the vector in the x-z plane in the anticlockwise sense. </p>

<p>For example we can chose our familiar \({\{|0\rangle, |1\rangle}\}\) basis and see that 
\[|\psi\rangle = \sin\frac\theta 2|0\rangle+e^{i\phi}\cos\frac\theta 2|1\rangle\] The coordinates of such a state will be 
\[r = \begin{pmatrix} \sin\theta \cos\phi\\ \sin\theta \sin\phi \\ \cos\theta \end{pmatrix}.\]
So the vector \(|0\rangle\) can be written as \(\begin{pmatrix} 0\\ 0 \\ 1 \end{pmatrix}\) and \(|1\rangle\) can be written as \(\begin{pmatrix} 0\\ 0 \\ -1 \end{pmatrix}\). Now it is common to get confused as to whether \(|0\rangle\) equals to \(\begin{pmatrix} 0\\ 0 \\ 1 \end{pmatrix}\) or \(\begin{pmatrix} 1 \\ 0 \\ \end{pmatrix}\)
as we discussed in the previous section. It is none! Both of these are just representations of the abstract state that we did to understand it better.<br>
Another crucial thing to note is that antipodal vectors form basis states of the system in the Bloch sphere while in the actual vector space, they are orthogonal and have an angle of \(\pi/2\). For example, the \({\{|+\rangle, |-\rangle}\}\) basis, \({\{|0\rangle, |1\rangle}\}\) basis or the \({\{|+i\rangle=\frac{1}{\sqrt2}(|0\rangle+i|1\rangle), |-i\rangle=\frac{1}{\sqrt2}(|0\rangle-i|1\rangle)}\}\) basis (which are along the z, x, and y axes respectively).</p>

<p><center>
<img src="images/sphere.png" alt="">
</center></p>

<h2 id="toc_6">Quantum Gates and Getting started with Qiskit</h2>

<p>I believe now we are ready to understand what quantum gates are and their significance. Since we know that measuring the qubit will collapse the system and we will lose the initially prepared state, we can try to manipulate that initial state of the qubit by passing it through different quantum gates in a quantum circuit without explicitly measuring it. This represents the transfer of quantum information. Notice here the analogy with classical bit manipulation in digital logic.</p>

<p>These gates have many interpretations. Mathematically they can be thought of as unitary operators that act on states (since the states are normalized, the operations of these states must be unitary). Visually, these gates correspond to movements of vectors along the Bloch sphere. </p>

<p>Let us now get started with coding them hands-on with qiskit which  is open-source SDK. With Qiskit, you can run your quantum programs and algorithms sitting at your home and without physically accessing any laboratory with a large quantum computer. You simulate your your quantum programs locally or even send them to IBM&#39;s quantum computers, and they&#39;ll return the result to you! </p>

<p>To install qiskit simply open the terminal and run
<code>pip install qiskit</code>
After running this command, you should have qiskit successfully installed in your system. 
We&#39;ll use jupyter notebook for our programs. To open jupyter notebook run
<code>jupyter notebook</code>
which will open a notebook and you can create a new file to start coding!</p>

<p>We begin by importing the qiskit module.</p>

<div><pre><code class="language-python">from qiskit import *</code></pre></div>

<p>Let us start by creating 1 quantum register and 1 classical register. We do this by the <code>QuantumRegister</code> and the <code>ClassicalRegister</code> functions respectively, and as the argument, we pass the number of bits we want.</p>

<div><pre><code class="language-python">qr = QuantumRegister(1)
cr = ClassicalRegister(1)</code></pre></div>

<p>Then we built a QuantumCircuit composed of the two classical and quantum bits by running</p>

<div><pre><code class="language-python">qc = QuantumCircuit(qr, cr)</code></pre></div>

<p>Here the variable &#39;qc&#39; has the quantum circuit in it. To draw the circuit at any point, we use the <code>draw()</code> function</p>

<div><pre><code class="language-python">qc.draw()</code></pre></div>

<p>This should return an output like this.</p>

<p><img src="images/quant_class_1.png" alt=""></p>

<p>We could have also done the above 4 lines by the <code>QuantumCircuit()</code> function.</p>

<div><pre><code class="language-python">qc = QuantumCircuit(1,1)
qc.draw()</code></pre></div>

<p>Here the first argument is the number of quantum bits, and the second argument is the number of classical bits.</p>

<p>By convention, all the qubits are initialized at the state \(|0\rangle\). Now let us look at some essential gates which we use to manipulate these qubits. </p>

<h3 id="toc_7">Hadamard Gate</h3>

<p>The <em>Hadamard gate</em> is the most important quantum logic gate. This gate is represented by the matrix \[H = \frac{1}{\sqrt2}\begin{pmatrix} +1 &amp; +1\\ +1 &amp; -1 \\ \end{pmatrix}.\]
A few operations of this gate are shown as follows, which can be checked by multiplying the Hadamard matrix on the left of the state vector.
\[
\begin{align}
H|0\rangle &amp;= \frac{1}{\sqrt 2}(|0\rangle-|1\rangle)= |-\rangle \\
H|1\rangle &amp;= \frac{1}{\sqrt 2}(|0\rangle+|1\rangle)= |+\rangle \\
H|+\rangle &amp;= |0\rangle \\
H|-\rangle &amp;= |1\rangle
\end{align}\]
On the Bloch sphere, it corresponds to a rotation of \(\pi\) around the \(\frac{x+z}{\sqrt2}\) axis. Equivalently, it is the combination of two rotations \(\pi\) around the z-axis and a \(\frac {\pi}{2}\) around the y-axis
This gate is used to introduce superposition within the states of the system. 
Let&#39;s code this in qiskit!  </p>

<div><pre><code class="language-python">qc.h(0)</code></pre></div>

<p>This adds a Hadamard gate on the number of qubits passed as the argument (Remember that arrays are numbered from 0 in python)</p>

<p>Let&#39;s draw the circuit again, and this time we&#39;ll beautify our circuits with matplotlib </p>

<div><pre><code class="language-python">%matplotlib inline 
qc.draw(&#39;mpl&#39;)</code></pre></div>

<p>The output should look like this</p>

<p><img src="images/had_1.png" alt=""></p>

<p>The circuit is read left to right (meaning that gates that are applied earlier in the circuit show up further to the left).</p>

<h2 id="toc_8">Simulating circuits with Aer</h2>

<p>Qiskit Aer is the package used for simulating quantum circuits. It provides many different backends for doing a simulation. </p>

<p>To simulate the above circuit, let&#39;s choose our backend as the qasm simulator. A quick digression about the qasm simulator: The qasm simulator acts like a real perfect quantum computer, and there would be some randomness in the results but no errors.  A useful feature of the qasm simulator is that it can mimic a real noisy quantum computer and is a quick way for us to get results.</p>

<div><pre><code class="language-python">simulator = Aer.get_backend(&#39;qasm_simulator&#39;)</code></pre></div>

<p>Next, we execute the circuit on the simulator and store the results in a variable called result and plot it&#39;s histogram.</p>

<div><pre><code class="language-python">from qiskit.visualization import plot_histogram

result = execute(qc, backend=simulator).result()
plot_histogram(result.get_counts(qc))</code></pre></div>

<p><img src="images/plot_1.png" alt=""></p>

<p>This plot may not make any sense at first, but keep in mind that the qasm simulator returns the counts on the classical register. Since we have not done any measurement on the circuit, it just gives us all counts on the default value of the classical register, which is 0.</p>

<p>However, if we measure the circuit before reading the counts, we see a much more familiar output. To measure, we use the <code>measure()</code> function and pass the quantum bits as the first argument and the classical bits into which we want the measurement as the second argument.</p>

<div><pre><code class="language-python">qc = QuantumCircuit(1,1)
qc.h(0)
qc.measure(range (1), range (1))
qc.draw(&#39;mpl&#39;)</code></pre></div>

<p><img src="images/had_measure.png" alt=""></p>

<div><pre><code class="language-python">simulator = Aer.get_backend(&#39;qasm_simulator&#39;)
result = execute(qc, backend=simulator).result()
plot_histogram(result.get_counts(qc))</code></pre></div>

<p><img src="images/pic.png" alt=""></p>

<p>Notice the difference between the above two circuits. After we perform the measurement in the second circuit, it collapses the qubit into one of the two classical bits. Since the Hadamard gate takes the input state of \(|0\rangle\) and puts it into an equal superposition of both the states, we see that the probability is roughly 50% for superposition collapsing into each of it&#39;s basis states. Also, since we have used the qasm simulator, which mimics a real noisy quantum computer, the probability is not precisely 50%. Let&#39;s see some more gates.</p>

<h3 id="toc_9">Pauli -X Gate</h3>

<p>This gate is represented by the matrix \[X = \begin{pmatrix} 0 &amp; 1\\ 1 &amp; 0 \\ \end{pmatrix}\]
This gate when operated on a single qubit acts as follows 
\[
\begin{align}
X|0\rangle &amp;= \begin{pmatrix} 0 &amp; 1\\ 1 &amp; 0 \\ \end{pmatrix}\cdot\begin{pmatrix} 1 \\ 0  \\ \end{pmatrix}= \begin{pmatrix} 0 \\ 1  \\ \end{pmatrix} = |1\rangle \\
X|1\rangle &amp;= \begin{pmatrix} 0 &amp; 1\\ 1 &amp; 0 \\ \end{pmatrix}\cdot\begin{pmatrix} 0 \\ 1  \\ \end{pmatrix}= \begin{pmatrix} 1 \\ 0  \\ \end{pmatrix} = |0\rangle \\
X|+\rangle &amp;= |+\rangle \\
X|-\rangle &amp;= |-\rangle
\end{align}\]
On the Bloch sphere, it corresponds to a rotation of \(\pi\) around the x-axis. Notice that the \(|0\rangle\) changes to \(|1\rangle\) and the \(|1\rangle\) changes to \(|0\rangle\). This gate is hence called the bit-flip and is analogous to the classical NOT gate.</p>

<p>Let us make a circuit using this</p>

<div><pre><code class="language-python">circuit = QuantumCircuit(1,1)
circuit.x(0)
circuit.h(0)
circuit.draw(&#39;mpl&#39;)</code></pre></div>

<p><img src="images/x_had_1.png" alt=""></p>

<p>This time, we&#39;ll look at a different simulator to run this called the state vector simulator. This simulator returns the quantum state, a complex vector of dimensions \(2^n\) where \(n\) is the number of qubits used. So be careful using this as it will quickly get too large to run on your machine.</p>

<p>Since the statevector only returns the quantum state and measuring the quantum state will collapse the system into it&#39;s basis states. Let us illustrate this by executing the above code.</p>

<div><pre><code class="language-python">simulator = Aer.get_backend(&#39;statevector_simulator&#39;)
result = execute(circuit, backend=simulator).result()
outputstate = result.get_statevector(circuit, decimals=4)
print (outputstate)</code></pre></div>

<p><img src="images/x_had_out_1.png" alt=""> </p>

<p>which is the quantum state of the system we are in. We can verify this by applying these gates mathematically as follows - 
\[HX|0\rangle = \frac{1}{\sqrt2}\begin{pmatrix} +1 &amp; +1\\ +1 &amp; -1 \\ \end{pmatrix}\begin{pmatrix} 0 &amp; 1\\ 1 &amp; 0 \\ \end{pmatrix}.\begin{pmatrix} 1 \\ 0  \\ \end{pmatrix}=\frac{1}{\sqrt2}\begin{pmatrix} +1 &amp; +1\\ +1 &amp; -1 \\ \end{pmatrix}.\begin{pmatrix} 0\\ 1 \\ \end{pmatrix}=\frac{1}{\sqrt2}\begin{pmatrix} +1\\ -1 \\ \end{pmatrix}\] which is consistent with what we get above on running the code.</p>

<p>Qiskit also offers a beautiful way to plot the real and imaginary components of the state density matrix as follows.</p>

<div><pre><code class="language-python">from qiskit.visualization import plot_state_city

plot_state_city(outputstate)</code></pre></div>

<p><img src="images/x_had_state_city_plot.png" alt=""></p>

<p>Now let us repeat this experiment by having measured the circuit 
beforehand</p>

<div><pre><code class="language-python">circuit = QuantumCircuit(1,1)
circuit.x(0)
circuit.h(0)
circuit.measure(range(1),range(1))
circuit.draw(&#39;mpl&#39;)</code></pre></div>

<p><img src="images/x_had_measure.png" alt=""></p>

<p>Now let&#39;s see what our plot gives us</p>

<div><pre><code class="language-python">simulator = Aer.get_backend(&#39;statevector_simulator&#39;)
result = execute(circuit, backend=simulator).result()
outputstate = result.get_statevector(circuit, decimals=4)
plot_state_city(outputstate)</code></pre></div>

<p><img src="images/x_had_measure_state_city_plot.png" alt=""></p>

<p>Voila! Our quantum state collapsed again after the measurement! Just what we&#39;d expect. Another interesting thing is if we do this experiment again, we might collapse the system into a different state which would give us a different plot. If we do this experiment a large number of times and note the number of times our system collapses into each of our states, we&#39;d find the proportion to agree with the square of the coefficients of basis states of the initial state of the system.</p>

<p>This was an introduction to quantum computing and hopefully by now you understand the power of qiskit in simulating quantum effects in circuits. We now move on to discuss the most basic quantum algorithm called Grover Search. Refer to the Grover.ipynb file for the code!</p>

<script type="text/javascript">
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1],i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(!s||!i)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&&t[i]){var o=t[i];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var m=r[p];if(r.length>e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&&h&&p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p<r.length-2&&(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w>=m.length)continue;var _=y.index+y[0].length,P=m.length+b.length;if(v=3,P>=_){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&&(f=y[1].length);var w=y.index+f,y=y[0].slice(f),_=w+y.length,S=m.slice(0,w),O=m.slice(_),j=[p,v];S&&j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",n.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
</script>

<script type="text/javascript">
Prism.languages.python={"triple-quoted-string":{pattern:/"""[\s\S]+?"""|'''[\s\S]+?'''/,alias:"string"},comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0},string:/("|')(?:\\?.)*?\1/,"function":{pattern:/((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g,lookbehind:!0},"class-name":{pattern:/(\bclass\s+)[a-z0-9_]+/i,lookbehind:!0},keyword:/\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/,"boolean":/\b(?:True|False)\b/,number:/\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,operator:/[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,punctuation:/[{}[\];(),.:]/};
</script>

<script type="text/x-mathjax-config">
(function () {

MathJax.Hub.Config({
	'showProcessingMessages': false,
	'messageStyle': 'none'
});

if (typeof MathJaxListener !== 'undefined') {
	MathJax.Hub.Register.StartupHook('End', function () {
		MathJaxListener.invokeCallbackForKey_('End');
	});
}

})();
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


</body>

</html>
